#ifndef CARDSDB_API_H
#define CARDSDB_API_H

/* RDM 12.0.14.3256 */

/*lint ++flb (treat this like a library header file - no warnings on unrefrenced symbols) */
#include "Db.h"
#include "Cursor.h"
#include "cardsdb.h"

namespace RDM_CPP {

class Cursor_card_info;
class Cursor_card_access_rules;

/** \brief The cardsdb Db class

 * This class provides the implementation for the cardsdb database
*/
class Db_cardsdb : public Db {
public:
    /** \brief Open the cardsdb database using the default name

       \return A validated Db_cardsdb object

        \par Locking Requirements
        None

        \throws rdm_exception (S_UNAVAIL, S_DBOPEN, S_INVDB, S_BADTYPE, S_INCOMPAT, S_TRACTIVE, S_DBD_NONAMES, S_TX_NO_REMOTE, S_NOMEMORY)
        \par Library
        rdmcppapi-12
       */
    static Db_cardsdb Open (
        RDM_OPEN_MODE mode=RDM_OPEN_SHARED,/**< [in] The database open mode */
        const void *dbd_array=NULL, /**< [in] A dbd array (generated by the ddlp -c option) */
        int32_t dbdsize=0, /**< [in] The size of the dbd array */
        const ENC *enc=NULL /**< [in] The encryption context to use when opening the database */
) throw (const rdm_exception&);

    /** \brief Open the cardsdb database using the specified name

       \return A validated Db_cardsdb object

        \par Locking Requirements
        None

        \throws rdm_exception (S_UNAVAIL, S_DBOPEN, S_INVDB, S_BADTYPE, S_INCOMPAT, S_TRACTIVE, S_DBD_NONAMES, S_TX_NO_REMOTE, S_NOMEMORY)
        \par Library
        rdmcppapi-12
       */
    static Db_cardsdb Open (
        const char *name, /**< [in] The database name to use for the open call */
        RDM_OPEN_MODE mode=RDM_OPEN_SHARED, /**< [in] The database open mode */
        const void *dbd_array=NULL, /**< [in] A dbd array (generated by the ddlp -c option) */
        int32_t dbdsize=0, /**< [in] The size of the dbd array */
        const ENC *enc=NULL /**< [in] The encryption context to use when opening the database */
) throw (const rdm_exception&);

#if !defined(RDM_NO_UNICODE)
    /** \copydoc Open(const char *, RDM_OPEN_MODE, const void *, int32_t, const ENC *) */
    static Db_cardsdb Open (
        const wchar_t *name, /**< [in] The database name to use for the open call */
        RDM_OPEN_MODE mode=RDM_OPEN_SHARED, /**< [in] The database open mode */
        const void *dbd_array=NULL, /**< [in] A dbd array (generated by the ddlp -c option) */
        int32_t dbdsize=0, /**< [in] The size of the dbd array */
        const ENC *enc=NULL /**< [in] The encryption context to use when opening the database */
        ) throw (const rdm_exception&);
#endif /*RDM_NO_UNICODE*/

    /** \brief Db_cardsdb Default Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (void) throw ();

    /** \brief Db_cardsdb Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (
       const Db& db /**< [in] A Db object used to create the Db_cardsdb */       ) throw ();

    /** \brief Db_cardsdb Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Db_cardsdb (
        const Db_cardsdb& /**< [in] The Db_cardsdb to copy */
        ) throw ();

    /** \brief Db_cardsdb assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one.

        \par Locking Requirements
        None

        \throws rdm_exception (CPP_INVALID_DB_TYPE)
        \par Library
        rdmcppapi-12
    */
    Db_cardsdb& operator = (
        const Db& /**< [in] An instance of the Db base class */
        ) throw (const rdm_exception&); /*lint !e1511 (this operator intentionally hides Db::operator=(const RDM_CPP::Db &)) */

    /** \brief Db_cardsdb assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one.

        \par Locking Requirements
        None

        \throws rdm_exception (CPP_INVALID_DB_TYPE)
        \par Library
        rdmcppapi-12
    */
    Db_cardsdb& operator = (
        const Db_cardsdb& /**< [in] An instance of the  Db_cardsdb class */
        ) throw ();

    /** \brief Db_cardsdb destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one

     */
    ~Db_cardsdb (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

    /** \brief Create a new card_info record

       Create a new card_info record using the specified values

       \returns A singleton Cursor_card_info object positioned to the new record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY, S_NOTLOCKED, S_NOTRANS, S_DUPLICATE)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info New_card_info_record (
        const struct card_info& fields /**< [in] The field values for the new record.  If fields values are not specified then default values will be used (a structure initialized to all 0s) */
        ) const throw (const rdm_exception&);

    /** \brief Create a new card_info record

       Create a new card_info record using the default values.  If the record has user fields the        default values will be a record structure initialized to all 0's.

       \returns A singleton Cursor_card_info object positioned to the new record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY, S_NOTLOCKED, S_NOTRANS, S_DUPLICATE)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info New_card_info_record (void) const throw (const rdm_exception&);

    /** \brief Create a new card_access_rules record

       Create a new card_access_rules record using the specified values

       \returns A singleton Cursor_card_access_rules object positioned to the new record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY, S_NOTLOCKED, S_NOTRANS, S_DUPLICATE)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_access_rules New_card_access_rules_record (
        const struct card_access_rules& fields /**< [in] The field values for the new record.  If fields values are not specified then default values will be used (a structure initialized to all 0s) */
        ) const throw (const rdm_exception&);

    /** \brief Create a new card_access_rules record

       Create a new card_access_rules record using the default values.  If the record has user fields the        default values will be a record structure initialized to all 0's.

       \returns A singleton Cursor_card_access_rules object positioned to the new record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY, S_NOTLOCKED, S_NOTRANS, S_DUPLICATE)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_access_rules New_card_access_rules_record (void) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info ordered by database address

       Create a new Cursor_card_info for doing a table scan of the card_info records.
       The cursor will contain a collection of all of the card_info records and will be initially positioned to the BeforeFirst position, unless a database address is specified and then the cursor will be positioned to the record at the specified database address.

       \returns A Cursor_card_info instance ordered by database address

        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info Get_card_info_records (
        const DB_ADDR& dba = NULL_DBA /**< [in] If dba is specified (and not NULL_DBA) the cursor will be positioned to the record at the dba location.  If dba is not specified (or is NULL_DBA) the cursor will be positioned to 'BeforeFirst' */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_access_rules ordered by database address

       Create a new Cursor_card_access_rules for doing a table scan of the card_access_rules records.
       The cursor will contain a collection of all of the card_access_rules records and will be initially positioned to the BeforeFirst position, unless a database address is specified and then the cursor will be positioned to the record at the specified database address.

       \returns A Cursor_card_access_rules instance ordered by database address

        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_access_rules Get_card_access_rules_records (
        const DB_ADDR& dba = NULL_DBA /**< [in] If dba is specified (and not NULL_DBA) the cursor will be positioned to the record at the dba location.  If dba is not specified (or is NULL_DBA) the cursor will be positioned to 'BeforeFirst' */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info instance based on the token_digest key

       Create a new Cursor_card_info based on and ordered by the token_digest key and position the cursor
       at the first record with a matching key value.

       If there is no exact key match, the cursor will be placed in the CURSOR_BETWEEN_KEYS position.
       Navigating forward (next) from that position will position
       the cursor at the next key value larger than the specified key
       value.  Navigating backward (prev) from that position will
       position the cursor at the next key value smaller than the
       specified key value. 

       \returns a Cursor_card_info positioned at the first record matching the key value.

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_NOT_LOCKED, S_TRPRECOMMITTED, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info Get_card_info_recordsBy_token_digest (const uint8_t token_digest_val[35] /**< [in] The value used for initially positioning the cursor */
        ) const throw (const rdm_exception&);
    /** \brief Obtain a Cursor_card_info instance based on the token_digest key

       Create a new Cursor_card_info based on the token_digest key and position the cursor
       to 'BeforeFirst'.  The cursor will be ordered by key value.

       \returns a Cursor_card_info ordered by key value and positioned to 'BeforeFirst'.

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_NOT_LOCKED, S_TRPRECOMMITTED, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info Get_card_info_recordsBy_token_digest () const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info based on the token_digest key containing records in the specified range of key values

       The Cursor_card_info will be ordered by key value and will be initially positioned
       to the 'BeforeFirst' position.
       \returns A Cursor_card_info containing a set of records in the specified key range

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_NOT_LOCKED, S_TRPRECOMMITTED, S_NOMEMORY)
        \par Library
        rdmcppapi-12
     */
    Cursor_card_info Get_card_info_recordsBy_token_digest_inRange (
        const uint8_t start_val[35], /**< [in] The key value used for the start of the range */
        const uint8_t end_val[35]= NULL /**< [in] The key value used for the end of the range.  If this value is not specified then the range will continue until the last key value */
        ) const throw (const rdm_exception&);

private:
    /** \brief Db_cardsdb reference operator

     */
    Db_cardsdb* operator & (void); /*lint !e1511 (this operator intentionally hides Db::operator&(void)) */

    /** \brief Db_cardsdb constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (
        IDb *idb /**< [in] A db interface class instance */
        ); /*lint !e1704 (this constructor is intentionally private) */

    /** \brief Get the Db_cardsdb dbType

       \return The Db_cardsdb dbType
     */
    static dbType Type (void);
};

/** \brief The card_info Cursor class

     This class provides the implementation for the card_info Cursor
*/
class Cursor_card_info : public Cursor 
{
public:
    /** \brief Get the type for objects of this class

        This method returns the record identifier of the record that is
        in the current position of cursor
        \return The type for Cursor_card_info objects
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR)
        \par Library
        rdmcppapi-12
    */
    static recordType Type (void);

    /** \brief Cursor_card_info default constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_info (void) throw ();

    /** \brief Cursor_card_info Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_info (
        const Cursor& cursor /**< [in] A Cursor object used to create the Cursor_card_info object */
        ) throw (const rdm_exception&);

    /** \brief Cursor_card_info Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Cursor_card_info (
        const Cursor_card_info& /**< [in] the Cursor_card_info to copy */
        ) throw ();

    /** \brief Cursor_card_info assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_info& operator = (
        const Cursor& cursor /**< [in] A base Cursor object */
        ) throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::operator=(const RDM_CPP::Cursor &)) */

    /** \brief Cursor_card_info assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_info& operator = (
        const Cursor_card_info& cursor /**< [in] A Cursor_card_info object */
        ) throw ();

    /*lint -esym(534,RDM_CPP::Cursor_card_info::First,RDM_CPP::Cursor_card_info::Next,RDM_CPP::Cursor_card_info::Prev,RDM_CPP::Cursor_card_info::Last) (the return value of these functions does not need to be checked) */
    /** \brief Navigate to the first record in the collection

    This method will position a cursor to the first record in the
    collection.  If there are no records in the collection then the
    cursor will be positioned to AfterLast.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_info& First (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_First ());
    } /*lint !e1511 (this intentionally hides Cursor::First(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the next record in the collection

    This method will position a cursor to the next record in the
    collection.  If the was positioned to the last record in the 
    collection then the cursor will be positioned to AfterLast.

    If the cursor was positioned to AfterLast an rdm_exception with the
    S_INVALID_ITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED, S_INVALID_ITERATION)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_info& Next (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_Next ());
    } /*lint !e1511 (this intentionally hides Cursor::Next(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the previous record in the collection

    This method will position a cursor to the previous record in the
    collection.  If the was positioned to the first record in the 
    collection then the cursor will be positioned to BeforeFirst.

    If the cursor was positioned to BeforeFirst an rdm_exception with the
    S_INVALID_ITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED, S_INVALID_ITERATION)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_info& Prev (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_Prev ());
    } /*lint !e1511 (this intentionally hides Cursor::Prev(void)) */ /*lint !e1774 (this will always be the right tyme so static_cast is sufficient) */

    /** \brief Navigate to the last record in the collection

    This method will position a cursor to the last record in the
    collection.  If there are no records in the collection then the
    cursor will be positioned to BeforeFirst.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_info& Last (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_Last ());
    } /*lint !e1511 (this intentionally hides Cursor::Last(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Get a singleton cursor positioned to the same record as the source cursor

        This method returns a singleton cursor positioned to the same record as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info GetSelf (void) const throw (const rdm_exception&)
    {
        return this->_GetSelf ();
    } /*lint !e1511 (this intentionally hides Cursor::GetSelf(void)) */

    /** \brief Get a clone of the source cursor

    This method create a clone of an existing cursor.  The resulting clone will be of the same type, contain the same records, and will have the same position and current record as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info Clone (void) const throw (const rdm_exception&)
    {
        return this->_Clone ();
    } /*lint !e1511 (this intentionally hides Cursor::Clone(void)) */

    /** \brief Create a new Cursor_card_info cursor ordered by the token_digest key.

        Create a new card_info cursor using token_digest key navigation and position the
        new cursor to BeforeFirst

        \return A Cursor_card_info ordered by the token_digest key

        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info GetRecordsBy_token_digest () const throw (const rdm_exception&);

    /** \brief Create a new card_info cursor doing token_digest key navigation.

         Create a new card_info cursor using token_digest key navigation and position the
         new cursor at same record as the source cursor.
         \return card_info cursor ordered by the token_digest key

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_NOMEMORY, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_info GetRecordsBy_token_digestAtRecord () const throw (const rdm_exception&);

    /** \brief Position the card_info cursor to the token_digest key value

    This method will position a cursor to the first record in the
    collection that has the key value specified by the
    key_value parameter.  The cursor can be any type of cursor and does
    not need to be a key scan cursor based on key_id.

    If there is no exact match then:

    - If the cursor is a key scan cursor based on the same key as the
    provided key value then the function will return S_NOTFOUND and the
    cursor will be placed in the CURSOR_BETWEEN_KEYS position.
    Navigating forward (next) from that position will position
    the cursor at the next key value larger than the specified key
    value.  Navigating backward (prev) from that position will
    position the cursor at the next key value smaller than the
    specified key value. 

    - Otherwise the function will throw a rdm_exception with the S_NOT_IN_CURSOR
    error code and the cursor position will be left unchanged.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOT_IN_CURSOR, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void KeyFindBy_token_digest (
        const uint8_t key_val[35] /**< [in] The value to use for the lookup */
        ) const throw (const rdm_exception&);

    /** \brief Set all of the field values of the record at the current cursor position

        This method updates all field values except for blobs in current
        record of the cursor.
        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTRANS, S_DUPLICATE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void SetFieldValues (
        const struct card_info &fields /**< [in] The new field values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::SetFieldValues(recordType, const void *, uint32_t) */

    /** \brief Get all of the field values for the record at the current cursor position

    This method reads all the (non blob) field values from the
    current record of cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void GetFieldValues (
        struct card_info &fields /**< [in] The buffer to place the field values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::GetFieldValues(recordType, void *, uint32_t, uint32_t *) */

    /** \brief Set the access_rules_record_addr field value for the current record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED, S_NOTRANS)
        \par Library
        rdmcppapi-12
    */
    void Set_access_rules_record_addr (
        const DB_ADDR &field_val /**< [in] The new value for the field */
        ) const throw (const rdm_exception&);

    /** \brief Get the access_rules_record_addr field value for the current record

    This method reads the value of a single field from the
    current record of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void Get_access_rules_record_addr (
        DB_ADDR &field_val /**< [out] The place to put the field value */
        ) const throw (const rdm_exception&);

    /** \brief Set the card_access_type field value for the current record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED, S_NOTRANS)
        \par Library
        rdmcppapi-12
    */
    void Set_card_access_type (
        const uint8_t &field_val /**< [in] The new value for the field */
        ) const throw (const rdm_exception&);

    /** \brief Get the card_access_type field value for the current record

    This method reads the value of a single field from the
    current record of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void Get_card_access_type (
        uint8_t &field_val /**< [out] The place to put the field value */
        ) const throw (const rdm_exception&);

    /** \brief Set the token_digest field value for the current record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED, S_NOTRANS)
        \par Library
        rdmcppapi-12
    */
    void Set_token_digest (
        const uint8_t field_val[35] /**< [in] The new value for the field */
        ) const throw (const rdm_exception&);

    /** \brief Get the token_digest field value for the current record

    This method reads the value of a single field from the
    current record of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void Get_token_digest (
        uint8_t field_val[35] /**< [out] The place to put the field value */        ) const throw (const rdm_exception&);

    /** \brief Set the last_digits field value for the current record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED, S_NOTRANS)
        \par Library
        rdmcppapi-12
    */
    void Set_last_digits (
        const char field_val[4] /**< [in] The new value for the field */
        ) const throw (const rdm_exception&);

    /** \brief Get the last_digits field value for the current record

    This method reads the value of a single field from the
    current record of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void Get_last_digits (
        char field_val[4] /**< [out] The place to put the field value */        ) const throw (const rdm_exception&);

    /** \brief Cursor_card_info Destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one. */
    ~Cursor_card_info (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

private:
    friend class Db_cardsdb;
    friend class Cursor_card_access_rules;
};

/** \brief The card_access_rules Cursor class

     This class provides the implementation for the card_access_rules Cursor
*/
class Cursor_card_access_rules : public Cursor 
{
public:
    /** \brief Get the type for objects of this class

        This method returns the record identifier of the record that is
        in the current position of cursor
        \return The type for Cursor_card_access_rules objects
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR)
        \par Library
        rdmcppapi-12
    */
    static recordType Type (void);

    /** \brief Cursor_card_access_rules default constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_access_rules (void) throw ();

    /** \brief Cursor_card_access_rules Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_access_rules (
        const Cursor& cursor /**< [in] A Cursor object used to create the Cursor_card_access_rules object */
        ) throw (const rdm_exception&);

    /** \brief Cursor_card_access_rules Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Cursor_card_access_rules (
        const Cursor_card_access_rules& /**< [in] the Cursor_card_access_rules to copy */
        ) throw ();

    /** \brief Cursor_card_access_rules assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_access_rules& operator = (
        const Cursor& cursor /**< [in] A base Cursor object */
        ) throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::operator=(const RDM_CPP::Cursor &)) */

    /** \brief Cursor_card_access_rules assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_access_rules& operator = (
        const Cursor_card_access_rules& cursor /**< [in] A Cursor_card_access_rules object */
        ) throw ();

    /*lint -esym(534,RDM_CPP::Cursor_card_access_rules::First,RDM_CPP::Cursor_card_access_rules::Next,RDM_CPP::Cursor_card_access_rules::Prev,RDM_CPP::Cursor_card_access_rules::Last) (the return value of these functions does not need to be checked) */
    /** \brief Navigate to the first record in the collection

    This method will position a cursor to the first record in the
    collection.  If there are no records in the collection then the
    cursor will be positioned to AfterLast.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_access_rules& First (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_First ());
    } /*lint !e1511 (this intentionally hides Cursor::First(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the next record in the collection

    This method will position a cursor to the next record in the
    collection.  If the was positioned to the last record in the 
    collection then the cursor will be positioned to AfterLast.

    If the cursor was positioned to AfterLast an rdm_exception with the
    S_INVALID_ITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED, S_INVALID_ITERATION)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_access_rules& Next (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_Next ());
    } /*lint !e1511 (this intentionally hides Cursor::Next(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the previous record in the collection

    This method will position a cursor to the previous record in the
    collection.  If the was positioned to the first record in the 
    collection then the cursor will be positioned to BeforeFirst.

    If the cursor was positioned to BeforeFirst an rdm_exception with the
    S_INVALID_ITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED, S_INVALID_ITERATION)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_access_rules& Prev (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_Prev ());
    } /*lint !e1511 (this intentionally hides Cursor::Prev(void)) */ /*lint !e1774 (this will always be the right tyme so static_cast is sufficient) */

    /** \brief Navigate to the last record in the collection

    This method will position a cursor to the last record in the
    collection.  If there are no records in the collection then the
    cursor will be positioned to BeforeFirst.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    const Cursor_card_access_rules& Last (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_Last ());
    } /*lint !e1511 (this intentionally hides Cursor::Last(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Get a singleton cursor positioned to the same record as the source cursor

        This method returns a singleton cursor positioned to the same record as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_access_rules GetSelf (void) const throw (const rdm_exception&)
    {
        return this->_GetSelf ();
    } /*lint !e1511 (this intentionally hides Cursor::GetSelf(void)) */

    /** \brief Get a clone of the source cursor

    This method create a clone of an existing cursor.  The resulting clone will be of the same type, contain the same records, and will have the same position and current record as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOMEMORY)
        \par Library
        rdmcppapi-12
    */
    Cursor_card_access_rules Clone (void) const throw (const rdm_exception&)
    {
        return this->_Clone ();
    } /*lint !e1511 (this intentionally hides Cursor::Clone(void)) */

    /** \brief Set all of the field values of the record at the current cursor position

        This method updates all field values except for blobs in current
        record of the cursor.
        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTRANS, S_DUPLICATE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void SetFieldValues (
        const struct card_access_rules &fields /**< [in] The new field values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::SetFieldValues(recordType, const void *, uint32_t) */

    /** \brief Get all of the field values for the record at the current cursor position

    This method reads all the (non blob) field values from the
    current record of cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void GetFieldValues (
        struct card_access_rules &fields /**< [in] The buffer to place the field values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::GetFieldValues(recordType, void *, uint32_t, uint32_t *) */

    /** \brief Set the access_data field value for the current record

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor record(s)

        \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOCR, S_NOTLOCKED, S_NOTRANS)
        \par Library
        rdmcppapi-12
    */
    void Set_access_data (
        const uint8_t field_val[500] /**< [in] The new value for the field */
        ) const throw (const rdm_exception&);

    /** \brief Get the access_data field value for the current record

    This method reads the value of a single field from the
    current record of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor record(s)

    \throws rdm_exception (S_TRPRECOMMITTED, S_INVCURSOR_OP, S_SET_GONE, S_RECORD_GONE, S_NOTLOCKED)
        \par Library
        rdmcppapi-12
    */
    void Get_access_data (
        uint8_t field_val[500] /**< [out] The place to put the field value */        ) const throw (const rdm_exception&);

    /** \brief Cursor_card_access_rules Destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one. */
    ~Cursor_card_access_rules (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

private:
    friend class Db_cardsdb;
    friend class Cursor_card_info;
};

}
/*lint --flb (turn off library header file option) */
#endif    /* CARDSDB_API_H */
