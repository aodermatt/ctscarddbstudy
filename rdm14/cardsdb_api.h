/*
 * Raima Database C++ Header File
 * This file is autogenerated, please don't edit the file
*/

#if !defined(__CARDSDB_API_H)
#define __CARDSDB_API_H

/* RDM 14.0.1.7027 */

/*lint ++flb (treat this like a library header file - no warnings on unrefrenced symbols) */
#include "cpp-db.h"
#include "cpp-cursor.h"
#include "cardsdb_structs.h"

namespace RDM_CPP {

class Cursor_card_info;
class Cursor_card_access_rules;

/** \brief The cardsdb Db class

 * This class provides the implementation for the cardsdb database
*/
class Db_cardsdb : public Db
{
public:
    /** \brief Open the cardsdb database using the specified name and mode

       \return A validated Db_cardsdb object

        \par Locking Requirements
        None

        \throws rdm_exception (eUNAVAIL, eINVDB, eOPENMODE, eINCOMPAT, eDBD_NONAMES, eTX_NO_REMOTE, eNOMEMORY)
        \par Library
        rdmcppapi-14
       */
    Db_cardsdb Open (
        const char *name, /**< [in] The database name to use for the open call */
        RDM_OPEN_MODE mode=RDM_OPEN_SHARED /**< [in] The database open mode */
        ) throw (const rdm_exception&);

#if !defined(RDM_NO_UNICODE)
    /** \copydoc Open(const char *, RDM_OPEN_MODE) */
    Db_cardsdb Open (
        const wchar_t *name, /**< [in] The database name to use for the open call */
        RDM_OPEN_MODE mode=RDM_OPEN_SHARED /**< [in] The database open mode */
        ) throw (const rdm_exception&);
#endif /*RDM_NO_UNICODE*/

    /** \brief Db_cardsdb Default Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (void) throw ();

    /** \brief Db_cardsdb Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (
       const Db& db /**< [in] A Db object used to create the Db_cardsdb */
       ) throw ();

    /** \brief Db_cardsdb Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Db_cardsdb (
        const Db_cardsdb& /**< [in] The Db_cardsdb to copy */
        ) throw ();

    /** \brief Db_cardsdb assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one.

        \par Locking Requirements
        None

        \throws rdm_exception (CPP_INVALID_DB_TYPE)
        \par Library
        rdmcppapi-14
    */
    Db_cardsdb& operator = (
        const Db& /**< [in] An instance of the Db base class */
        ) throw (const rdm_exception&); /*lint !e1511 (this operator intentionally hides Db::operator=(const RDM_CPP::Db &)) */

    /** \brief Db_cardsdb assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one.

        \par Locking Requirements
        None

        \throws rdm_exception (CPP_INVALID_DB_TYPE)
        \par Library
        rdmcppapi-14
    */
    Db_cardsdb& operator = (
        const Db_cardsdb& /**< [in] An instance of the  Db_cardsdb class */
        ) throw ();

    /** \brief Db_cardsdb destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one

     */
    ~Db_cardsdb (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

    /** \brief Insert a row in the card_info table

       Insert a new card_info row using the specified column values

       \returns A singleton Cursor_card_info object positioned to the new row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eNOMEMORY, eNOTLOCKED, eNOSTARTUPDATE, sDUPLICATE)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info Insert_card_info_Row (
        const CARD_INFO& columnValues /**< [in] The column values for the new row. */
        ) const throw (const rdm_exception&);

    /** \brief Insert a row in the card_access_rules table

       Insert a new card_access_rules row using the specified column values

       \returns A singleton Cursor_card_access_rules object positioned to the new row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eNOMEMORY, eNOTLOCKED, eNOSTARTUPDATE, sDUPLICATE)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_access_rules Insert_card_access_rules_Row (
        const CARD_ACCESS_RULES& columnValues /**< [in] The column values for the new row. */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info ordered by rowId

       Create a new Cursor_card_info for doing a table scan of the card_info rows.
       The cursor will contain a collection of all of the card_info rows and will be initially positioned to the BeforeFirst position, unless a rowId is specified and then the cursor will be positioned to the row at the specified rowId.

       \returns A Cursor_card_info instance ordered by rowId

        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info Get_card_info_Rows (
        RDM_ROWID_T rowId = NULL_ROWID /**< [in] If rowId is specified (not NULL_ROWID) the cursor will be positioned to the row at the rowId location.  If a rowId is not specified (is NULL_ROWID) the cursor will be positioned to 'BeforeFirst' */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_access_rules ordered by rowId

       Create a new Cursor_card_access_rules for doing a table scan of the card_access_rules rows.
       The cursor will contain a collection of all of the card_access_rules rows and will be initially positioned to the BeforeFirst position, unless a rowId is specified and then the cursor will be positioned to the row at the specified rowId.

       \returns A Cursor_card_access_rules instance ordered by rowId

        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_access_rules Get_card_access_rules_Rows (
        RDM_ROWID_T rowId = NULL_ROWID /**< [in] If rowId is specified (not NULL_ROWID) the cursor will be positioned to the row at the rowId location.  If a rowId is not specified (is NULL_ROWID) the cursor will be positioned to 'BeforeFirst' */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info instance based on the token_digest key

       Create a new Cursor_card_info based on and ordered by the token_digest key and position the cursor
       at the first row with a matching key value.

       If there is no exact key match, the cursor will be placed in the CURSOR_BETWEEN_KEYS position.
       Navigating forward (next) from that position will position
       the cursor at the next key value larger than the specified key
       value.  Navigating backward (prev) from that position will
       position the cursor at the next key value smaller than the
       specified key value. 

       \returns a Cursor_card_info positioned at the first row matching the key value.

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (eNOTLOCKED, ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info Get_card_info_RowsBy_token_digest (
        const uint8_t keyValue[35] /**< [in] The value used for initially positioning the cursor */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info instance based on the token_digest key

       Create a new Cursor_card_info based on the token_digest key and position the cursor
       to 'BeforeFirst'.  The cursor will be ordered by key value.

       \returns a Cursor_card_info ordered by key value and positioned to 'BeforeFirst'.

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (eNOTLOCKED, ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info Get_card_info_RowsBy_token_digest () const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info based on the token_digest key containing rows in the specified range of key values

       The Cursor_card_info will be ordered by key value and will be initially positioned
       to the 'BeforeFirst' position.
       \returns A Cursor_card_info containing a set of rows in the specified key range

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (eNOTLOCKED, ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
     */
    Cursor_card_info Get_card_info_RowsBy_token_digest_InRange (
        uint8_t start_val, /**< [in] The key value used for the start of the range */
        uint8_t end_val /**< [in] The key value used for the end of the range.  If this value is not specified then the range will continue until the last key value */
        ) const throw (const rdm_exception&);

    /** \brief Obtain a Cursor_card_info based on the token_digest key containing rows in the specified range of key values

       The Cursor_card_info will be ordered by key value and will be initially positioned
       to the 'BeforeFirst' position.
       \returns A Cursor_card_info containing a set of rows starting with the specified key value and continuing to the final key value

        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (eNOTLOCKED, ePRECOMMITTED, eNOMEMORY)
        \par Library
        rdmcppapi-14
     */
    Cursor_card_info Get_card_info_RowsBy_token_digest_InRange (
        uint8_t start_val /**< [in] The key value used for the start of the range */
        ) const throw (const rdm_exception&);

    Cursor_card_info Get_card_info_RowsBy_token_digest_InRange (
        const CARD_INFO_TOKEN_DIGEST_KEY& start_val, /**< [in] The key value used for the start of the range */
        const CARD_INFO_TOKEN_DIGEST_KEY& end_val/**< [in] The key value used for the end of the range.  If this value is not specified then the range will continue until the last key value */
        ) const throw (const rdm_exception&);

    Cursor_card_info Get_card_info_RowsBy_token_digest_InRange (
        const CARD_INFO_TOKEN_DIGEST_KEY& start_val/**< [in] The key value used for the start of the range */
        ) const throw (const rdm_exception&);


private:
    /** \brief Db_cardsdb reference operator

     */
    Db_cardsdb* operator & (void); /*lint !e1511 (this operator intentionally hides Db::operator&(void)) */

    /** \brief Db_cardsdb constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Db_cardsdb interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The will initialize the number of references to the 
        underlying implementation object to one. */
    Db_cardsdb (
        IDb *idb /**< [in] A db interface class instance */
        ); /*lint !e1704 (this constructor is intentionally private) */

    /** \brief Get the Db_cardsdb dbType

       \return The Db_cardsdb dbType
     */
    static dbType Type (void);
};

/** \brief The card_info Cursor class

     This class provides the implementation for the card_info Cursor
*/
class Cursor_card_info : public Cursor 
{
public:
    /** \brief Get the type for objects of this class

        This method returns the table identifier of the table that is
        in the current position of cursor
        \return The type for Cursor_card_info objects
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW)
        \par Library
        rdmcppapi-14
    */
    static RDM_TABLE_ID GetTableId (void);

    /** \brief Cursor_card_info default constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_info (void) throw ();

    /** \brief Cursor_card_info Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_info (
        const Cursor& cursor /**< [in] A Cursor object used to create the Cursor_card_info object */
        ) throw (const rdm_exception&);

    /** \brief Cursor_card_info Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Cursor_card_info (
        const Cursor_card_info& /**< [in] the Cursor_card_info to copy */
        ) throw ();

    /** \brief Cursor_card_info assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_info& operator = (
        const Cursor& cursor /**< [in] A base Cursor object */
        ) throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::operator=(const RDM_CPP::Cursor &)) */

    /** \brief Cursor_card_info assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_info& operator = (
        const Cursor_card_info& cursor /**< [in] A Cursor_card_info object */
        ) throw ();

    /*lint -esym(534,RDM_CPP::Cursor_card_info::First,RDM_CPP::Cursor_card_info::Next,RDM_CPP::Cursor_card_info::Prev,RDM_CPP::Cursor_card_info::Last) (the return value of these functions does not need to be checked) */
    /** \brief Navigate to the first row in the collection

    This method will position a cursor to the first row in the
    collection.  If there are no rows in the collection then the
    cursor will be positioned to AfterLast.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_info& MoveToFirst (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_MoveToFirst ());
    } /*lint !e1511 (this intentionally hides Cursor::First(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the next row in the collection

    This method will position a cursor to the next row in the
    collection.  If the was positioned to the last row in the 
    collection then the cursor will be positioned to AfterLast.

    If the cursor was positioned to AfterLast an rdm_exception with the
    eINVITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED, eINVITERATION)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_info& MoveToNext (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_MoveToNext ());
    } /*lint !e1511 (this intentionally hides Cursor::Next(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the previous row in the collection

    This method will position a cursor to the previous row in the
    collection.  If the was positioned to the first row in the 
    collection then the cursor will be positioned to BeforeFirst.

    If the cursor was positioned to BeforeFirst an rdm_exception with the
    eINVITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED, eINVITERATION)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_info& MoveToPrev (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_MoveToPrev ());
    } /*lint !e1511 (this intentionally hides Cursor::Prev(void)) */ /*lint !e1774 (this will always be the right tyme so static_cast is sufficient) */

    /** \brief Navigate to the last row in the collection

    This method will position a cursor to the last row in the
    collection.  If there are no rows in the collection then the
    cursor will be positioned to BeforeFirst.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_info& MoveToLast (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_info&>(this->_MoveToLast ());
    } /*lint !e1511 (this intentionally hides Cursor::Last(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Get a singleton cursor positioned to the same row as the source cursor

        This method returns a singleton cursor positioned to the same row as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info GetSelf (void) const throw (const rdm_exception&)
    {
        return this->_GetSelf ();
    } /*lint !e1511 (this intentionally hides Cursor::GetSelf(void)) */

    /** \brief Get a clone of the source cursor

    This method create a clone of an existing cursor.  The resulting clone will be of the same type, contain the same rows, and will have the same position and current row as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info GetClone (void) const throw (const rdm_exception&)
    {
        return this->_GetClone ();
    } /*lint !e1511 (this intentionally hides Cursor::GetClone(void)) */

    /** \brief Create a new Cursor_card_info cursor ordered by the token_digest key.

        Create a new card_info cursor using token_digest key navigation and position the
        new cursor to BeforeFirst

        \return A Cursor_card_info ordered by the token_digest key

        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_info GetRowsBy_token_digest () const throw (const rdm_exception&);

    /** \brief Position the card_info cursor to the token_digest key value

    This method will position a cursor to the first row in the
    collection that has the key value specified by the
    key_value parameter.  The cursor can be any type of cursor and does
    not need to be a key scan cursor based on key_id.

    If there is no exact match then:

    - If the cursor is a key scan cursor based on the same key as the
    provided key value then the function will return sNOTFOUND and the
    cursor will be placed in the CURSOR_BETWEEN_KEYS position.
    Navigating forward (next) from that position will position
    the cursor at the next key value larger than the specified key
    value.  Navigating backward (prev) from that position will
    position the cursor at the next key value smaller than the
    specified key value. 

    - Otherwise the function will throw a rdm_exception with the eNOTINCURSOR
    error code and the cursor position will be left unchanged.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTINCURSOR, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void MoveTo_token_digest (
        const uint8_t key_val[35]/**< [in] The value to use for the lookup */
        ) const throw (const rdm_exception&);

    /** \brief Set all of the column values of the row at the current cursor position

        This method updates all columnv values except for blobs in current
        row of the cursor.
        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOSTARTUPDATE, sDUPLICATE, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void UpdateRow (
        const CARD_INFO &columnValues /**< [in] The new column values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::UpdateRow(const void *, size_t) */

    /** \brief Get all of the column values for the row at the current cursor position

    This method reads all the (non blob) column values from the
    current row of cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void ReadRow (
        CARD_INFO &columnValues /**< [in] The buffer to place the column values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::ReadRow(void *, size_t, size_t *) */

    /** \brief Update the access_rules_record_addr column value for the current row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED, eNOSTARTUPDATE)
        \par Library
        rdmcppapi-14
    */
    void Update_access_rules_record_addr (
        const uint64_t &columnValue /**< [in] The new value for the column */
        ) const throw (const rdm_exception&);

    /** \brief Get the access_rules_record_addr column value for the current row

    This method reads the value of a single column from the
    current row of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void Read_access_rules_record_addr (
        uint64_t &columnValue /**< [out] The place to put the column value */
        ) const throw (const rdm_exception&);

    /** \brief Update the card_access_type column value for the current row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED, eNOSTARTUPDATE)
        \par Library
        rdmcppapi-14
    */
    void Update_card_access_type (
        const uint8_t &columnValue /**< [in] The new value for the column */
        ) const throw (const rdm_exception&);

    /** \brief Get the card_access_type column value for the current row

    This method reads the value of a single column from the
    current row of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void Read_card_access_type (
        uint8_t &columnValue /**< [out] The place to put the column value */
        ) const throw (const rdm_exception&);

    /** \brief Update the token_digest column value for the current row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED, eNOSTARTUPDATE)
        \par Library
        rdmcppapi-14
    */
    void Update_token_digest (
        const uint8_t columnValue[35] /**< [in] The new value for the column */
        ) const throw (const rdm_exception&);

    /** \brief Get the token_digest column value for the current row

    This method reads the value of a single column from the
    current row of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void Read_token_digest (
        uint8_t columnValue[35] /**< [out] The place to put the column value */
        ) const throw (const rdm_exception&);

    /** \brief Update the last_digits column value for the current row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED, eNOSTARTUPDATE)
        \par Library
        rdmcppapi-14
    */
    void Update_last_digits (
        const char columnValue[5] /**< [in] The new value for the column */
        ) const throw (const rdm_exception&);

    /** \brief Get the last_digits column value for the current row

    This method reads the value of a single column from the
    current row of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void Read_last_digits (
        char columnValue[5] /**< [out] The place to put the column value */
        ) const throw (const rdm_exception&);

    /** \brief Cursor_card_info Destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_info interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one. */
    ~Cursor_card_info (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

private:
    friend class Db_cardsdb;
    friend class Cursor_card_access_rules;
};

/** \brief The card_access_rules Cursor class

     This class provides the implementation for the card_access_rules Cursor
*/
class Cursor_card_access_rules : public Cursor 
{
public:
    /** \brief Get the type for objects of this class

        This method returns the table identifier of the table that is
        in the current position of cursor
        \return The type for Cursor_card_access_rules objects
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW)
        \par Library
        rdmcppapi-14
    */
    static RDM_TABLE_ID GetTableId (void);

    /** \brief Cursor_card_access_rules default constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The default constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_access_rules (void) throw ();

    /** \brief Cursor_card_access_rules Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The constructor will initialize the number of references to the 
        underlying implementation object to one. */
    Cursor_card_access_rules (
        const Cursor& cursor /**< [in] A Cursor object used to create the Cursor_card_access_rules object */
        ) throw (const rdm_exception&);

    /** \brief Cursor_card_access_rules Copy Constructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The copy constructor will increment the number of references to the 
        underlying implementation object by one. */
    Cursor_card_access_rules (
        const Cursor_card_access_rules& /**< [in] the Cursor_card_access_rules to copy */
        ) throw ();

    /** \brief Cursor_card_access_rules assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_access_rules& operator = (
        const Cursor& cursor /**< [in] A base Cursor object */
        ) throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::operator=(const RDM_CPP::Cursor &)) */

    /** \brief Cursor_card_access_rules assignment operator

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The assignment operator will increment the number of references to the 
        underlying implementation object it is being assigned to by one. The assignment
        operator will decrement the number of references to the underlying implementation
        object for the old value that is being over written by one. */
    Cursor_card_access_rules& operator = (
        const Cursor_card_access_rules& cursor /**< [in] A Cursor_card_access_rules object */
        ) throw ();

    /*lint -esym(534,RDM_CPP::Cursor_card_access_rules::First,RDM_CPP::Cursor_card_access_rules::Next,RDM_CPP::Cursor_card_access_rules::Prev,RDM_CPP::Cursor_card_access_rules::Last) (the return value of these functions does not need to be checked) */
    /** \brief Navigate to the first row in the collection

    This method will position a cursor to the first row in the
    collection.  If there are no rows in the collection then the
    cursor will be positioned to AfterLast.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_access_rules& MoveToFirst (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_MoveToFirst ());
    } /*lint !e1511 (this intentionally hides Cursor::First(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the next row in the collection

    This method will position a cursor to the next row in the
    collection.  If the was positioned to the last row in the 
    collection then the cursor will be positioned to AfterLast.

    If the cursor was positioned to AfterLast an rdm_exception with the
    eINVITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED, eINVITERATION)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_access_rules& MoveToNext (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_MoveToNext ());
    } /*lint !e1511 (this intentionally hides Cursor::Next(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Navigate to the previous row in the collection

    This method will position a cursor to the previous row in the
    collection.  If the was positioned to the first row in the 
    collection then the cursor will be positioned to BeforeFirst.

    If the cursor was positioned to BeforeFirst an rdm_exception with the
    eINVITERATION error code will be thrown
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED, eINVITERATION)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_access_rules& MoveToPrev (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_MoveToPrev ());
    } /*lint !e1511 (this intentionally hides Cursor::Prev(void)) */ /*lint !e1774 (this will always be the right tyme so static_cast is sufficient) */

    /** \brief Navigate to the last row in the collection

    This method will position a cursor to the last row in the
    collection.  If there are no rows in the collection then the
    cursor will be positioned to BeforeFirst.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    const Cursor_card_access_rules& MoveToLast (void) const throw (const rdm_exception&)
    {
        return static_cast<const Cursor_card_access_rules&>(this->_MoveToLast ());
    } /*lint !e1511 (this intentionally hides Cursor::Last(void)) */ /*lint !e1774 (this will always be the right type so static_cast is sufficient) */

    /** \brief Get a singleton cursor positioned to the same row as the source cursor

        This method returns a singleton cursor positioned to the same row as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_access_rules GetSelf (void) const throw (const rdm_exception&)
    {
        return this->_GetSelf ();
    } /*lint !e1511 (this intentionally hides Cursor::GetSelf(void)) */

    /** \brief Get a clone of the source cursor

    This method create a clone of an existing cursor.  The resulting clone will be of the same type, contain the same rows, and will have the same position and current row as the source cursor
        \par Locking Requirements
        None

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOMEMORY)
        \par Library
        rdmcppapi-14
    */
    Cursor_card_access_rules GetClone (void) const throw (const rdm_exception&)
    {
        return this->_GetClone ();
    } /*lint !e1511 (this intentionally hides Cursor::GetClone(void)) */

    /** \brief Set all of the column values of the row at the current cursor position

        This method updates all columnv values except for blobs in current
        row of the cursor.
        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOSTARTUPDATE, sDUPLICATE, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void UpdateRow (
        const CARD_ACCESS_RULES &columnValues /**< [in] The new column values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::UpdateRow(const void *, size_t) */

    /** \brief Get all of the column values for the row at the current cursor position

    This method reads all the (non blob) column values from the
    current row of cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void ReadRow (
        CARD_ACCESS_RULES &columnValues /**< [in] The buffer to place the column values */
        ) const throw (const rdm_exception&); /*lint !e1511 (this intentionally hides Cursor::ReadRow(void *, size_t, size_t *) */

    /** \brief Update the access_data column value for the current row

        \par Locking Requirements in Shared/Shared-Strict Modes
        An Update transaction with locks on the relevant cursor row(s)

        \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOCURRENTROW, eNOTLOCKED, eNOSTARTUPDATE)
        \par Library
        rdmcppapi-14
    */
    void Update_access_data (
        const uint8_t columnValue[500] /**< [in] The new value for the column */
        ) const throw (const rdm_exception&);

    /** \brief Get the access_data column value for the current row

    This method reads the value of a single column from the
    current row of the cursor.
        \par Locking Requirements in ReadOnly-Strict/Shared-Strict Modes
        A Snapshot transaction or a Read transaction with locks on the relevant cursor row(s)

    \throws rdm_exception (ePRECOMMITTED, eINVCURSOROP, eOWNERDELETED, eSINGLETONDELETED, eNOTLOCKED)
        \par Library
        rdmcppapi-14
    */
    void Read_access_data (
        uint8_t columnValue[500] /**< [out] The place to put the column value */
        ) const throw (const rdm_exception&);

    /** \brief Cursor_card_access_rules Destructor

        The default constructor, constructor, copy constructor, assignment operator, and 
        destructor implement a smart pointer for the Cursor_card_access_rules interface.
        The number of references to the underlying 
        implementation object will be maintained.  When the number of references 
        to an implementation object is down to zero, the object will be released.

        The destructor will decrement the number of references to the 
        underlying implementation object by one. */
    ~Cursor_card_access_rules (); /*lint !e1509 (the base class destructor is intentionally not virtual) */

private:
    friend class Db_cardsdb;
    friend class Cursor_card_info;
};

}
/*lint --flb (turn off library header file option) */

#endif /* __CARDSDB_API_H */
