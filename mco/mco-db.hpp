#include <cassert>

#include "database_profiler.hpp"
#include <common.h>     // samples/native/common area - start up code for db
#include <testdb.hpp>   // Generated by Schema

#ifndef MCO_DBNAME
#define MCO_DBNAME "testdb"
#endif

#define DATABASE_SZ            16 * 1024 * 1024
#define CACHE_SZ               16 * 1024 * 1024
#define MEM_PAGE_SIZE          512
#define DISK_PAGE_SIZE         4096

int  INITIAL_OBJECT_NUM = 20 * 1000 * 1000;
int  REQUEST_TIME       = 30; // 30 seconds

class MCODatabase
{
    mco_device_t dev[4];
    char db_name[64];
    bool closed;

public:
    MCODatabase(const char *name)
    {
        mco_db_params_t db_params;
        mco_error_set_handler(&sample_errhandler);
        mco_runtime_start();
        strcpy(db_name, name);

        /* Configure first memory device as a plain conventional memory region */
        dev[0].type       = MCO_MEMORY_CONV;
        dev[0].assignment = MCO_MEMORY_ASSIGN_DATABASE;
        dev[0].size       = DATABASE_SZ;
        dev[0].dev.conv.ptr = (void*)malloc(dev[0].size);

        /* Configure conventional memory region for cache */
        dev[1].type       = MCO_MEMORY_CONV;
        dev[1].assignment = MCO_MEMORY_ASSIGN_CACHE;
        dev[1].size       = CACHE_SZ;
        dev[1].dev.conv.ptr = (void*)malloc(dev[1].size);

        /* Configure FILE memory device for main database storage */
        dev[2].type = MCO_MEMORY_FILE;
        dev[2].assignment = MCO_MEMORY_ASSIGN_PERSISTENT;
        sprintf(dev[2].dev.file.name, FILE_PREFIX "%s.dbs", db_name);
        dev[2].dev.file.flags = MCO_FILE_OPEN_DEFAULT;

        /* Configure FILE memory device for transaction log */
        dev[3].type       = MCO_MEMORY_FILE;
        dev[3].assignment = MCO_MEMORY_ASSIGN_LOG;
        sprintf(dev[3].dev.file.name, FILE_PREFIX "%s.log", db_name);
        dev[3].dev.file.flags = MCO_FILE_OPEN_DEFAULT;

        /* Initialize and customize the database parameters */
        mco_db_params_init ( &db_params );                  /* Initialize the params with default values */
        db_params.mem_page_size      = MEM_PAGE_SIZE;       /* Set page size for in-memory part */
        db_params.disk_page_size     = DISK_PAGE_SIZE;      /* Set page size for persistent storage */
        db_params.db_max_connections = 5;                   /* Set total number of connections to the database */
 
        /* Open a database on the configured devices with given params */
        CHECK(mco_db_open_dev(db_name, testdb_get_dictionary(), dev, 4, &db_params ));
        closed = false;
    }

    const char *name() {
        return db_name;
    }

    void close() {
        if (! closed) {
            CHECK(mco_db_close(db_name));
            free(dev[0].dev.conv.ptr);
            free(dev[1].dev.conv.ptr);
            /* Stop eXtremeDB runtime */
            mco_runtime_stop();
            closed = true;
        }
    }

    ~MCODatabase() {
        close();
    }

};

class MCOConnection
{
    mco_db_h con;
public:
    MCOConnection(MCODatabase &database) {
        CHECK(mco_db_connect(database.name(), &con));
    }
    
    void disconnect() {
        if (con) {
            CHECK(mco_db_disconnect(con));
            con = 0;
        }
    }

    bool is_database_empty()
    {
        mco_trans_h t;
        mco_cursor_t csr;
        bool result = false;
        CHECK(mco_trans_start(con, MCO_READ_ONLY, MCO_TRANS_FOREGROUND, &t));
        MCO_RET rc = testdb::ListEntry::by_salted_key::cursor(t, &csr);
        if (rc == MCO_S_CURSOR_EMPTY) {
            result = true;
        } else {
            CHECK(rc);
        }
        CHECK(mco_trans_rollback(t));
        return result;
    }

    void set_commit_policy(MCO_COMMIT_POLICY policy) {
        mco_disk_transaction_policy(con, policy);
    }

    ~MCOConnection() {
        disconnect();
    }
    friend class MCOTransaction;
};

class MCOTransaction
{
    mco_trans_h trans;
    mco_db_h con;
public:
    MCOTransaction(MCOConnection &mcocon) : trans(0), con(mcocon.con) {}

    void start(MCO_TRANS_TYPE type) {
        CHECK(mco_trans_start(con, type, MCO_TRANS_FOREGROUND, &trans));
    }

    void commit() {
        if (trans) {
            CHECK(mco_trans_commit(trans));
            trans = 0;
        }
    }

    void rollback() {
        if (trans) {
            CHECK(mco_trans_rollback(trans));
            trans = 0;
        }
    }

    operator mco_trans_h() {
        return trans;
    }

    ~MCOTransaction() {
        rollback();
    }
};

namespace Database {

class MCO_ProfilerImpl : public ProfilerImpl 
{
public:
    //  RDM_ProfilerImpl(const std::string & metrics_log_filename);
    MCO_ProfilerImpl(); 
    ~MCO_ProfilerImpl();

    bool open_db(const unsigned number_of_threads); 

    void tx_begin();
    void create_rec(const SaltedKey& sk);
    void update_rec(const SaltedKey& sk);
    void delete_rec(const SaltedKey& sk);
    void tx_end();

    void find_rec(const SaltedKey& sk);

    void tx_sync();

private:
    MCODatabase * database;
    MCOConnection * con;
    MCOConnection * con2;
    MCOTransaction * t;
    testdb::ListEntry le;
};

} // end namespace Database


