/* Generated by eXtremeDB Schema Compiler, build 1792, rev. stable, rev. 19776
 * at Sat Nov 19 20:51:21 2016
 */

#include "testdb.h"
#include "mcowrap.h"


/*---------------------------------------------------------------------*/
/* calculator                                                          */

mco_calculator_h testdb_get_calculator(void)
{
  return (mco_calculator_h)NULLPTR;
}


/*---------------------------------------------------------------------*/
/* dictionary                                                          */

static mco_dictionary_t  dict; 
mco_dictionary_h testdb_get_dictionary(void)
{ 
  static int dictionary_ready = 0; 

  if( ! dictionary_ready ) 
  {
    static mco_dict_field_t v_field_info[3] = { 
    /* ListEntry */
    {"is_good", {1, 1, 8, 1, 1, 8}, 1, 0, 0, -1, 1, -1, 0, 1, 1, 65535, 65535, 0, 0, 0 /* 2 */},
    {"meta_info", {8, 4, 0, 8, 4, 0}, 12, 0, 0, -1, 8, -1, 0, 2, 2, 65535, 65535, 0, 0, 0 /* 3 */},
    {"salted_key", {35, 1, 9, 35, 1, 9}, 7, 8, 0, -1, 35, -1, 0, 0, 0, 65535, 65535, 0, 0, 0 /* 1 */}
    };

    static mco_dict_struct_t v_struct_info[1] = { 
    { "ListEntry", 0, 3, (v_field_info + 0), 44, 4, 44, 4 }
    };

    dictionary_ready = 1;

    {
      static const char * v_class_names[] = 
      {
        0, 
        "ListEntry"   , /* [1] */
        0
      };

      dict.str_class_names = v_class_names;
    }


    {
      static const char * v_index_names[] = 
      {
        "ListEntry.by_salted_key"   , /* [0] */
        0
      };

      dict.str_index_names = v_index_names;
    }

    {
      static  mco_dict_class_info_t class_inf[2] = { 
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
        { 0, 0, -1, -1, 44, 0, -1, 0, 0, -1, -2, 48, (v_struct_info + 0), 44, 0, 0 }  /* ListEntry */ 
      };
      dict.v_class_info = class_inf;
    }


    dict.v_desc_events = (mco_dict_event_t *)0;
    

    dict.v_all_struct = v_struct_info;
    {
      static mco_dict_index_field_t v_all_index_fields[ 1] = {
          { 9, -1, 4294967295U, 35, 7, 0, 0, -1 } /* [0] */
      }; 

      static mco_dict_index_t v_all_indexes_info[ 1] = {
          { 1, 2, 1, -1, 2084, & v_all_index_fields[0], 0, -1 } /* ListEntry.by_salted_key [0] */
      }; 

      dict.v_desc_indexes = v_all_indexes_info;
    }


    dict.v_desc_colls = (mco_dict_collation_t *)0;
    
    dict.version_major             = 7;
    dict.version_minor             = 0;
    dict.version_build             = 1792;
    dict.magic_number              = 9;
    dict.oid_is_supported          = 0;
    dict.auto_oid_supported        = 0;
    dict.flags                     = 0;
    dict.n_class_codes             = 1;
    dict.n_list_indexes            = 0;
    dict.n_autoid_indexes          = 0;
    dict.n_history_indexes         = 0;
    dict.n_userdef_indexes         = 0;
    dict.n_desc_indexes            = 1;
    dict.n_desc_events             = 0;
    dict.n_desc_colls              = 0;
    dict.n_structs                 = 1;
    dict.num_oid_estimation        = 0;
    dict.num_HA_estimation         = 0;
    dict.max_numof_indexes_per_obj = 1;
    dict.exact_OID_sizeof          = 0;
    dict.layout_OID_size           = 0;
    dict.sizeof_mco_offs_t[0]      = 4;
    dict.sizeof_mco_offs_t[1]      = sizeof(mco_offs_t);
    dict.sizeof_mco_size_t[0]      = 4;
    dict.sizeof_mco_size_t[1]      = sizeof(mco_size_t);
    dict.init_i_data.ptr           = 0;
    dict.init_i_data_n             = 0;
    dict.init_d_data.ptr           = 0;
    dict.init_d_data_n             = 0;
  }

  return &dict; 
}

MCO_RET      ListEntry_new                                    ( mco_trans_h t, /*OUT*/ ListEntry *handle )
{ return mco_w_new_obj_noid( t, 44, 1, (mco_objhandle_h)handle);
}

MCO_RET      ListEntry_delete                                 ( ListEntry *handle )
{ return mco_w_obj_delete( (mco_objhandle_h)handle); 
}

MCO_RET      ListEntry_set_allocation_block_size             (mco_trans_h t, mco_size_t block_size)
{ return mco_set_class_allocation_block_size(t, 1, block_size); 
}

MCO_RET      ListEntry_set_caching_priority                  (mco_trans_h t, int priority)
{ return mco_set_class_caching_priority(t, 1, priority); 
}

MCO_RET      ListEntry_delete_all                             ( mco_trans_h t )
{ return mco_w_obj_delete_all( t, 1 ); 
}

MCO_RET      ListEntry_checkpoint                             ( ListEntry *handle )
{ return mco_w_obj_checkpoint( (mco_objhandle_h)handle );
}

MCO_RET      ListEntry_salted_key_get                         ( ListEntry *handle, /*OUT*/ char * dest, uint2 dest_size)
{ return mco_w_chars_get( (mco_objhandle_h) handle, 9, 0, dest, dest_size, 35);
}

MCO_RET      ListEntry_salted_key_put                         ( ListEntry *handle, const char * src, uint2 len) 
{ return mco_w_chars_put( (mco_objhandle_h)handle, 9, 0, src, len, 35, 1);
}

MCO_RET      ListEntry_is_good_get                            ( ListEntry *handle, /*OUT*/ uint1 * result)
{ return mco_w_b1_get( (mco_objhandle_h) handle, 8, 1, result);
}

MCO_RET      ListEntry_is_good_put                            ( ListEntry *handle, uint1 value )
{ return mco_w_b1_put( (mco_objhandle_h) handle, 8, 1, 0, (uint1) value);
}

MCO_RET      ListEntry_meta_info_get                          ( ListEntry *handle, /*OUT*/ uint8 * result)
{ return mco_w_b8_get( (mco_objhandle_h) handle, 0, 2, result);
}

MCO_RET      ListEntry_meta_info_put                          ( ListEntry *handle, uint8 value )
{ return mco_w_b8_put( (mco_objhandle_h) handle, 0, 2, 0, & value);
}

MCO_RET      ListEntry_from_cursor                            ( mco_trans_h t, mco_cursor_h c, /*OUT*/ ListEntry *handle )
{ return mco_w_obj_from_cursor( t, c, 1, (mco_objhandle_h)handle ); 
}

MCO_RET      ListEntry_by_salted_key_index_cursor             ( mco_trans_h t, /*OUT*/ mco_cursor_h c )
{ return mco_w_index_cursor( t, 0, c );
}

MCO_RET      ListEntry_by_salted_key_search                   ( mco_trans_h t, /*INOUT*/ mco_cursor_h c, MCO_OPCODE op_, const char *salted_key_key_, uint2 sizeof_salted_key_key_ )
{ mco_external_field_t a_ [1];
  mco_external_field_h pa_ = a_;
  pa_->field_type = 7; pa_->v.ptr_size = sizeof_salted_key_key_; pa_->ptr = salted_key_key_; 

  return mco_w_tree_find(t,c,op_,a_);
}

MCO_RET      ListEntry_by_salted_key_compare                  ( mco_trans_h t, mco_cursor_h c, const char *salted_key_key_, uint2 sizeof_salted_key_key_, /*OUT*/ int *result_ )
{ mco_external_field_t a_[1];
  mco_external_field_h pa_ = a_;
  pa_->field_type = 7; pa_->v.ptr_size = sizeof_salted_key_key_; pa_->ptr = salted_key_key_; 
  return mco_w_cursor_compare( t, c, a_, result_);
}

MCO_RET      ListEntry_by_salted_key_pattern_size             ( const char *salted_key_key_, uint2 sizeof_salted_key_key_, /*OUT*/ uint4 *size_)
{ mco_external_field_t a_ [2];
  mco_external_field_h pa_ = a_;
  pa_->field_type = 7; pa_->v.ptr_size = sizeof_salted_key_key_; pa_->ptr = salted_key_key_; 
  (pa_+1)->field_type=0;
   return mco_pattern_size( a_,size_);
}

MCO_RET      ListEntry_by_salted_key_pattern_search           ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern, mco_size_t memsize , const char *salted_key_key_, uint2 sizeof_salted_key_key_ )
{ mco_external_field_t a_ [2];
  mco_external_field_h pa_ = a_;
  pa_->field_type = 7; pa_->v.ptr_size = sizeof_salted_key_key_; pa_->ptr = salted_key_key_; 
  (pa_+1)->field_type=0;
  return mco_pattern_search(t, c, allocated_pattern, memsize, a_);
}

MCO_RET      ListEntry_by_salted_key_pattern_next             ( mco_trans_h t, mco_cursor_h c, /*INOUT*/ void *allocated_pattern )
{ return mco_pattern_next(t, c , allocated_pattern,  0);
}

MCO_RET      ListEntry_by_salted_key_locate                   ( mco_trans_h t, /*OUT*/ mco_cursor_h c, ListEntry * handle)
{ return mco_w_cursor_locate( t, 0, (mco_objhandle_h)handle, c);
}

MCO_RET      ListEntry_by_salted_key_find                     ( mco_trans_h t, const char *salted_key_key_, uint2 sizeof_salted_key_key_, /*OUT*/ ListEntry *handle_)
{ mco_external_field_t a_[1];
  mco_external_field_h pa_ = a_;
  pa_->field_type = 7; pa_->v.ptr_size = sizeof_salted_key_key_; pa_->ptr = salted_key_key_; 
  return mco_w_tree_find_scalar(t, 0, a_, (mco_objhandle_h)handle_);
}

MCO_RET      ListEntry_fixed_get                              ( ListEntry *handle_, ListEntry_fixed* dst_ )
{ MCO_RET rc_ = MCO_S_OK, has_nulls_ = MCO_S_OK;
  return
    (rc_ = ListEntry_salted_key_get(handle_, dst_->salted_key, 35)) == MCO_S_OK &&
    (rc_ = ListEntry_is_good_get(handle_, &dst_->is_good)) == MCO_S_OK &&
    (rc_ = ListEntry_meta_info_get(handle_, &dst_->meta_info)) == MCO_S_OK
  ? has_nulls_ : rc_;
}

MCO_RET      ListEntry_fixed_put                              ( ListEntry *handle_, ListEntry_fixed const* src_ )
{ MCO_RET rc_;
  return
    (rc_ = ListEntry_salted_key_put(handle_, src_->salted_key, 35)) == MCO_S_OK &&
    (rc_ = ListEntry_is_good_put(handle_, src_->is_good)) == MCO_S_OK &&
    (rc_ = ListEntry_meta_info_put(handle_, src_->meta_info)) == MCO_S_OK
  ? MCO_S_OK : rc_;
}

